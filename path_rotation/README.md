# Круговой шифратор

Время = 2сек. Память = 512мб.

## Сложность = ?

Как известно самое дорогое и полезное оборудование для проведение опытов хранится за замком защищенным паролем. Но что делать если этот пароль был утерян? Ответом конечно же является Универсальное Устройство Восстановления Паролей (УУВП), которое позволяет восстановить пароль к любому замку.

Однако это устройство присутствовало в единственном экземпляре и было давно утеряно, остались только чертежи самого устройства, но не программа к нему. Во избежание появления казусных ситуаций вам доверили написание прошивки для УУВП, которая должна соответствовать Универсальному Интерфейсу Восстановления Паролей (УИВП).

Согласно документации к интерфейсу, на вход устройства подается бинарное дерево с корнем в вершине 1, при этом на каждом ребре присутствует вес w<sub>i</sub>. Далее для получение паро\ля устройство должно выдать ответы на q запросов.

Запросы представляют собой пару из вершин u<sub>i</sub> и v<sub>i</sub>. Ответом на запрос является максимальная сумма весов ребер на пути от u<sub>i</sub> до v<sub>i</sub> которую можно получить, после применения не более одного вращения пути между любыми двумя вершинами a и b, которые не лежат на пути от u<ub>i</sub> до v<sub>i</sub>.

В документации к устройству была пометка, что вращением пути между вершинами a и b называется процесс циклического сдвига вправо весов ребер на пути из a в b. А именно w<sub>path<sub>2</sub></sub> cтановится равным w<sub>path<sub>1</sub></sub>, w<sub>path<sub>3</sub></sub> меняется на w<sub>path<sub>2</sub></sub> и так далее до w<sub>path<sub>k</sub></sub>, также w<sub>path<sub>1</sub></sub> заменяется на w<sub>path<sub>k</sub></sub>. При этом path<sub>i</sub> -- i-е ребро на пути из вершины a в вершину b. Таким образом происходит изменение весов ребер.

Так как запросов достаточно много, а отвечать на них нужно за доли секунды, то эту непростую задачу по написанию прошивки поручили именно вам.

    
## Входные данные

Первая строка входных содержит одно целое число n (1 <= n <= 5000) -- количество вершин в дереве.

Следующие n строк описывают вершины бинарного дереве. i-я вершина описывается тремя целыми числами u<sub>i</sub>, v<sub>i</sub> и w<sub>i</sub> (0 <= u<sub>i></sub>, v<sub>i</sub> <= n, 0 <= w_i <= 10^9) -- правый и левый потомки i-ой вершины, а также вес ребра от вершины i до его предка.

Следующая строка содержит целое число q (0 <= q <= 2 * 10 ^ 5) -- количество запросов.

Далее q строк описывают запросы к устройству. Запрос описывается целыми числами a<sub>i</sub> и b<sub>i</sub> (1 <= a<sub>i</sub>, b<sub>i</sub> <= n, a<sub>i</sub> != b<sub>i</sub>) -- вершины пути для которого нужно найти максимальную сумму весов ребер на пути из u<sub>i</sub> в v<sub>i</sub>.

Гарантируется, что данные описывают корректное бинарное дерево.

## Выходные данные

Для каждого запроса выведите единственное число -- максимальную сумму весов, которую можно получить применив одно вращение пути двух вершин не находящихся на пути из u<sub>i</sub> в v<sub>i</sub> для i-го запроса.

### Входные данные

10<br>
2 3 10<br>
7 6 4<br>
4 5 1<br>
0 0 9<br>
0 0 7<br>
8 9 7<br>
0 0 1<br>
10 0 6<br>
0 0 0<br>
0 0 5<br>
3<br>
7 10<br>
5 9<br>
1 4<br>


### Выходные данные

19<br>
23<br>
17<br>
